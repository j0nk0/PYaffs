Objheader for tcpdump starts at offset 0x64d4B40

	-> parent objid is 0x26020000

The objheader for its parent node is at offset 0x64D0100

	-> The closest thing to the objid that appears is 0x260200 at offset 0x64d0305

	-> The bytes at 0x64D0305 are part of a cluster of 16 bytes that repeat every 512 bytes

	-> There is another 0x00 in that cluster

	-> There are always two 0xFF bytes in that cluster of 16 bytes

Hypothesis:
	-> This repeating cluster of 16 bytes is the spare memory
	-> Bytes in that spare area are swapped around compared to the format set in the YAFFS1 tag structure but are nonetheless the tags. the two 0xFF bytes match the 'should be FF' field
	-> But there should be FOUR 0xFF bytes, not just two!!!!!!!!


On a fully-used chunk (such as one in the middle of a file, we'll have 512 == 0x400 data bytes
If a yaffs2 tag is used, we should see 0x00000400 but we don't see that.
In a yaffs1 tag, we should see 10 BITS being 0b1000000000 ... and it appears we do although the bits are swapped around
	-> Because of this, in a full tag, we should have 0x?00 for the length immediately followed by an objid

In a yaffs1 tag, the objid is an unsigned int defined on 18 bits. Therefore
The chunkID should cover 5 hex digits
Furthermore, objectHeader IDs have a chunkID of 0

THe first spare in the file is: 



============== June 2014

Let's look at a chunk of contiguous XML from system.img

There's a chunk of 512 bytes of XML at 0xB21790 followed by 16 bytes of mystery stuff at 0xB21990
Then 512 bytes of XML from 0xB219A0 from 0xB21BA0 followed by another 16 bytes of crud

First 16-byte chunk of mystery:	FF 00 23 01 00 00 00 08 64 47 F2 FA E7 D2 F7 FF
Next chunk:			FF 00 00 0C FF FF FF 0C 2D FF C6 D0 31 CC FC FF
Next chunk:			FF 00 00 00 0C AA AA C5 34 09 6F F0 14 C5 F2 FF
Next chunk:			FF 00 10 00 00 0D 01 00 B9 D5 1A 55 7B 31 F5 FF

According to the YAFFS spec, each one of these 16-byte blocks should contain 8 bytes of tags, 6 bytes of ECC, 1 byte of block status and 1 unused byte

Furthermore, the tags should follow this pattern:
---
typedef struct {
	unsigned chunkId:20; //chunk number in file
	unsigned serialNumber:2; //serial number for chunk
	unsigned byteCount:10; //number of bytes of data used in this chunk
	unsigned objectId:18; //the object id that this chunk belongs to.
	unsigned ecc:12; //ECC on tags
	unsigned unusedStuff:2; //unused
} yaffs_Tags;
---

If we assume that the tags are the first 8 bytes in the chunk, then the first chunk has:

FF		00		23		01		00		00		00		08
1111 1111	0000 0000 	0010 0011 	0000 0001	0000 0000	0000 0000	0000 0000	0000 1000

-> Chunk Id: 11111111000000000010
-> Serial : 00
-> Byte count: 1100000001
-> Object ID: 000000000000000000
-> Tag ECC: 000000000010
-> Unused: 00


Second chunk: 
FF		00		00		0C		FF		FF		FF		0C
1111 1111	0000 0000	0000 0000	0000 1100	1111 1111	1111 1111	1111 1111	0000 1100


If there are 512 bytes used in a chunk, then we should have 10 bits with the values:
1 0 0 0 0 0 0 0 0 0

A 1 and 9 0's


==========================

We know that the chunkId (20 bits!) should be zero for an object header. Here's the chunk for the tcpdump header:
FF 00 10 00 00 28 02 00 8B D2 82 2F 77 0C FC FF

11111111000000000001000000000000000000000010100000000010000000001000101111010010100000100010111101110111000011001111110011111111


The offset for the chunkId would be one of: 21, 22, 23

The chunk for xbin (a directory!!!) is:
FF 00 10 00 00 26 02 00 D9 8B A0 90 4F D6 FE FF
11111111000000000001000000000000000000000010011000000010000000001101100110001011101000001001000001001111110101101111111011111111
                                        <-objid---------->
                              <bytec.nt>
We know that the parent objID for the tcpdump header is 26 02 00 00 (little endian) when written on 32 bits
Since an objid is only 18 bits in the header, this should fit on 18 bits: 00 0000 0010 0010 0110

The objectID starts on bit number 41 of the chunk (assuming the numbering of bits starts at 1)!!!

Since this is *NOT* a data chunk, the byte cound should be ten zero bits

Can we say that the byte count is from bit #31 -> bit #40
If we look at the above XML chunk, this yields a byte count of

1111111100000000001000110000000100000000000000000000000000001000
256???? Could be a OBO error???

====================
There exists a /usr/share/zoneinfo directory

The objectHeader for the 'usr' directory in system.img is at 0x957047E
The parent object Id is 01 00 00 00
The spare chunk is FF 00 10 00 00 D7 03 00 EE A1 07 CB 6F 0D F6 FF

The objectHeader for the 'share' directory in system.img is at 0x9578040
The parent object ID is D7 03 00 00 (in NAND order!)
-> 0x03D7
-> 000000001111010111
The spare chunk is FF 00 10 00 00 E0 03 00 0A B2 9F C5 DE D3 F9 FF

The objectHeader for the 'zoneinfo' directory in system.img is at 0x957887E
The parent object Id is E0 03 00 00
-> 0x03E0
-> 000000001111100000
The spare chunk is FF 00 10 00 00 E1 03 00 79 64 C9 3B 2A CE FC FF


Furthermore, there is a /usr/share/zoneinfo/zoneinfo.idx file

The objectHeader for which is at 0x95F8680
The parent object Id is E1 03 00 00
-> 0x03E1
The spare chunk is FF 00 10 00 00 E3 03 00 49 87 1F 38 21 84 F5 FF
The object ID is 0x03E3 ????



------------ June 2nd

It seems ONE in every FOUR spares is well-formed (ie. with a sensible objid) These *always* have the 20 bits from 20:40 set to zero

In fact, it looks like we don't *REALLY* have a pattern of 1 512-byte page followed by 16 bytes of spare.
Instead, we have one 2048-byte page *INTERLACED* with 4 * 16 bytes of spare. We know that the objectId is found in the first 16 bytes with something that looks a lot like the chunkId in the second 16-byte... blob for lack of a better word
